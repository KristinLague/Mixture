#pragma kernel GenerateVertexPositionBuffer

#pragma enable_d3d11_debug_symbols

ByteAddressBuffer           _MeshVertexBuffer;
ByteAddressBuffer           _MeshIndexBuffer;
int                         _MeshVertexStride;
int                         _DispatchSizeX;
int                         _MeshVertexCount;

// TODO: half3 position + original position output for vertex shader
RWStructuredBuffer<float3>  _OutputVertexPositions;

float3x3 rotationMatrix(float3 axis, float angle)
{
    axis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;
    
    return float3x3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,
                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,
                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);
}

[numthreads(64, 1, 1)]
void GenerateVertexPositionBuffer(uint2 id : SV_DispatchThreadID)
{
    int indexBufferIndex = (id.x + id.y * _DispatchSizeX) * 3;

    // Fetch triangle indices
    uint i0 = _MeshIndexBuffer.Load((indexBufferIndex + 0) << 2);
    uint i1 = _MeshIndexBuffer.Load((indexBufferIndex + 1) << 2);
    uint i2 = _MeshIndexBuffer.Load((indexBufferIndex + 2) << 2);

    // Fetch vertices
    // TODO: vertex position offset
    float3 v0 = asfloat(_MeshVertexBuffer.Load3(i0 * _MeshVertexStride));
    float3 v1 = asfloat(_MeshVertexBuffer.Load3(i1 * _MeshVertexStride));
    float3 v2 = asfloat(_MeshVertexBuffer.Load3(i2 * _MeshVertexStride));

    // Calculate trangle centroid:
    float3 c = (v0 + v1 + v2) / 3.0;

    // Center triangle in the middle of the screen
    v0 -= c;
    v1 -= c;
    v2 -= c;

    // Comput normal after centering the triangle to avoid cross resulting in 0
    // TODO: protection for completely flat triangle (will result in NaN in output)
    float3 normal = cross(v0, v1);
    float3 cameraForward = float3(0, 0, -1);

    // TODO: transform the triangle vertices to face camera.
    float3 d = cross(normal, cameraForward);
    float cosAngle = dot(d, d);
    float3x3 m = rotationMatrix(normalize(d), acos(cosAngle));
    v0 = mul(v0, m);
    v1 = mul(v1, m);
    v2 = mul(v2, m);

    // Output transformed vertices
    _OutputVertexPositions[indexBufferIndex + 0] = v0;
    _OutputVertexPositions[indexBufferIndex + 1] = v1;
    _OutputVertexPositions[indexBufferIndex + 2] = v2;
}
